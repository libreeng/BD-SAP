using FSMExtension.Data;
using FSMExtension.Models;
using FSMExtension.Models.Fsm;
using FSMExtension.Repositories;
using FSMExtension.Services;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace FSMExtension.Controllers
{
    [ApiController]
    [Route("api/v1")]
    public class ConnectionsController : ControllerBase
    {
        public ConnectionsController(
            IOnsightConnectService connectService,
            IOnsightWorkspaceService workspaceService,
            IOnsightFlowService onsightFlowService,
            IFsmApiService fsmApiService,
            IDomainMappingRepository domainRepo,
            ILogger<ConnectionsController> logger)
        {
            OnsightConnectService = connectService;
            OnsightWorkspaceService = workspaceService;
            OnsightFlowService = onsightFlowService;
            FsmApiService = fsmApiService;
            DomainRepository = domainRepo;
            FsmMetadataBuilder = new FsmMetadataBuilder();
            Logger = logger;
        }

        private IOnsightConnectService OnsightConnectService { get; }

        private IOnsightWorkspaceService OnsightWorkspaceService { get; }

        private IOnsightFlowService OnsightFlowService { get; }

        private IFsmApiService FsmApiService { get; }

        private IDomainMappingRepository DomainRepository { get; }

        private IMetadataBuilder FsmMetadataBuilder { get; }

        private ILogger<ConnectionsController> Logger { get; }

        /// <summary>
        /// Endpoint which generates an Onsight Connect call URI using the given from/to email addresses.
        /// This endpoint is reachable by both the mobile UI (who generates this endpoint directly
        /// from the FSM mobile configuration) and by the web UI (which generates this as part
        /// of the GetConnections call below).
        /// 
        /// Note that the caller's platform (PC/iOS/Android) will be automatically detected.
        /// 
        /// Security note: as there is not built-in support for authentication from the FSM mobile
        /// configuration, this endpoint is open. As callers must still authenticate within the
        /// Onsight Connect application before using any URLs generated by this method, the risk is limited.
        /// 
        /// The URI that is generated by this method can then be directly accessed by the caller
        /// to start the Onsight Connect call.
        /// </summary>
        /// <param name="from">Email address of the person initiaing the Onsight Connect call</param>
        /// <param name="to"></param>
        /// <param name="meta">A semi-colon separated list of key-value pairs (colon separated) of data
        /// which will be included as metadata in the Onsight Connect call.</param>
        /// <returns></returns>
        [HttpGet]
        [Route("fsm/connection")]
        public async Task<IActionResult> GetConnection(
            [FromQuery] string from,
            [FromQuery] string to,
            [FromQuery] string meta)
        {
            Logger.LogDebug($"GetConnection: from={from}, to={to}, meta={meta}");

            // Try finding the Onsight API Key corresponding to the 'from' email address
            var domainMapping = await DomainRepository.GetFromUserEmailAsync(from);
            Logger.LogDebug($"GetConnection get domain_mapping success = {domainMapping != null}");
            if (domainMapping == null)
                return NotFound();

            // Generate metadata structure based on CrmSource and 'meta' string
            var metadata = FsmMetadataBuilder.Build(meta);

            // Fetch and return Onsight Connect URL using APIKey + 'from' + 'to' + metadata struct
            var platform = Utils.DetectPlatform(Request);
            Logger.LogInformation($"Detected platform {platform}.");
            var uri = await OnsightConnectService.GetUriAsync(platform, domainMapping.OnsightApiKey, from, to, metadata);

            if (string.IsNullOrEmpty(uri))
                return NotFound();

            return Ok(uri);
        }

        /// <summary>
        /// Endpoint which returns Onsight Workspace documents using the given from email address and activityCode.
        /// 
        /// Note that the caller's platform (PC/iOS/Android) will be automatically detected.
        /// 
        /// The list of documents that are generated by this method contain Download URLs that can then be directly accessed by the user
        /// to open Onsite Workspace.
        /// </summary>
        /// <param name="from">Email address of the FSM logged in user requesting the Onsite Workspace documents</param>
        /// <param name="activityCode">The activityCode from SAP FSM that is referenced as metadata in workspace documents.</param>
        /// <returns></returns>
        [HttpGet]
        [Route("fsm/workspace-documents")]
        public async Task<IActionResult> GetWorkspaceDocuments(
        [FromQuery] string from,
        [FromQuery] string activityCode)
        {
            Logger.LogDebug($"GetConnection: from={from}");

            // Try finding the Onsight API Key corresponding to the 'from' email address
            var domainMapping = await DomainRepository.GetFromUserEmailAsync(from);
            Logger.LogDebug($"GetWorkspaceDocuments get domain_mapping success = {domainMapping != null}");
            if (domainMapping == null)
                return NotFound();

            // Fetch and return Onsight Workspace documents using APIKey + activityCode
            var platform = Utils.DetectPlatform(Request);
            Logger.LogInformation($"Detected platform {platform}.");
            var documents = await OnsightWorkspaceService.GetWorkspaceDocumentsAsync(domainMapping.OnsightApiKey, activityCode);

            if (string.IsNullOrEmpty(documents))
                return NotFound();

            return Ok(documents);
        }

        [HttpPost]
        [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]
        [Route("fsm/attachment")]
        public async Task<IActionResult> InsertAttachment(
            [FromQuery(Name = "a")] string activityId,
            [FromQuery(Name = "ac")] string accountId,
            [FromQuery(Name = "c")] string companyId,
            [FromQuery(Name = "h")] string cloudHost,
            [FromBody] List<OnsightWorkspaceDocument> documents)
        {
            // Look up FSM company (and its associated FSM auth token) based on 'accountId' + 'companyId'
            var domainMapping = await DomainRepository.GetFromFsmAccountIdAsync(accountId);

            var company = domainMapping.FsmAccount.FindCompany(companyId);
            if (company == null)
                return NotFound();

            var attachments = await FsmApiService.CreateAttachmentAsync(activityId, documents, company, cloudHost, domainMapping.OnsightApiKey);

            return Ok(attachments);
        }

        [HttpPost]
        [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]
        [Route("fsm/reports")]
        public async Task<IActionResult> InsertReport(
            [FromQuery(Name = "a")] string activityId,
            [FromQuery(Name = "ac")] string accountId,
            [FromQuery(Name = "c")] string companyId,
            [FromQuery(Name = "h")] string cloudHost,
            [FromBody] List<JobOfWorkFlow> jobsOfWorkFlow)
        {
            // Look up FSM company (and its associated FSM auth token) based on 'accountId' + 'companyId'
            var domainMapping = await DomainRepository.GetFromFsmAccountIdAsync(accountId);

            var company = domainMapping.FsmAccount.FindCompany(companyId);
            if (company == null)
                return NotFound();

            var attachments = await FsmApiService.CreateFlowAttachmentForActivityAsync(activityId, jobsOfWorkFlow, company, cloudHost, domainMapping.OnsightApiKey);

            return Ok(attachments);
        }

        /// <summary>
        /// Gets a list of Connections defined within the given CRM source object.
        /// 
        /// This endpoint is invoked by the web UI only (not mobile) and uses an internal
        /// Bearer token for authentication.
        /// </summary>
        /// <returns></returns>
        [HttpGet]
        [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]
        [Route("fsm/connections")]
        public async Task<IActionResult> GetConnections(
            [FromQuery(Name = "h")] string cloudHost,
            [FromQuery(Name = "a")] string accountId,
            [FromQuery(Name = "c")] string companyId,
            [FromQuery(Name = "av")] string activityId,
            [FromQuery(Name = "u")] string userId,
            [FromQuery(Name = "from")] string fromEmail)
        {
            var companyIdentifier = new FsmUserId(cloudHost, accountId, companyId, userId);

            var domainMapping = await DomainRepository.GetFromFsmAccountIdAsync(accountId);
            var company = domainMapping.FsmAccount.FindCompany(companyId);
            if (company == null)
                return NotFound();

            var activityResult = await GetActivity(cloudHost, accountId, companyId, activityId);
            var activity = (activityResult as OkObjectResult).Value as Dtos.FsmActivity;
            if (activity == null)
                return NotFound();

            var contacts = new List<Contact>();

            // Get remote expert, either designated by the Equipment or the Activity.Contact
            var equipment = await FsmApiService.GetEquipmentAsync(cloudHost, company, domainMapping, activity.EquipmentId);
            var remoteExpert = await GetRemoteExpertAsync(cloudHost, company, activity, equipment, fromEmail);
            if (remoteExpert != null)
                contacts.Add(remoteExpert);

            // Get responsible's details from activity.responsibles[]. This is the assigned field worker.
            var responsibles = await FsmApiService.GetPersonsAsync(cloudHost, company, activity.Responsibles);
            contacts.AddRange(responsibles.Select(r => new Contact
            {
                Name = $"{r.FirstName} {r.LastName}",
                Title = r.PositionName ?? r.JobTitle,
                Role = ContactRole.FieldTech,
                Connection = GetConnectionUrl(fromEmail, r.EmailAddress, equipment?.Code, activity.Code)
            }));

            foreach (var c in contacts)
            {
                Logger.LogDebug($"/connections generated URL '{c.Connection}'");
            }

            return Ok(contacts);
        }

        [HttpPatch]
        [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]
        [Route("fsm/activity-update")]
        public async Task<IActionResult> UpdateActivity(
            [FromQuery(Name = "h")] string cloudHost,
            [FromQuery(Name = "a")] string accountId,
            [FromQuery(Name = "c")] string companyId,
            [FromQuery(Name = "av")] string activityId,
            [FromQuery(Name = "w")] string selectedWorkFlowId)
        {
            var domainMapping = await DomainRepository.GetFromFsmAccountIdAsync(accountId);
            var company = domainMapping.FsmAccount.FindCompany(companyId);
            if (company == null)
                return NotFound();

            var updateActivityWithSelectedOptionId = await FsmApiService.UpdateActivtySelectedOption(selectedWorkFlowId, cloudHost, company, activityId);

            return Ok(updateActivityWithSelectedOptionId);
        }

        [HttpGet]
        [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]
        [Route("fsm/import-jobs")]
        public async Task<IActionResult> ImportFlowJobsAsync(
            [FromQuery(Name = "h")] string cloudHost,
            [FromQuery(Name = "a")] string accountId,
            [FromQuery(Name = "c")] string companyId,
            [FromQuery(Name = "av")] string activityId)
        {
            var domainMapping = await DomainRepository.GetFromFsmAccountIdAsync(accountId);
            var company = domainMapping.FsmAccount.FindCompany(companyId);
            if (company == null)
                return NotFound();
            
            var activityResult = await GetActivity(cloudHost, accountId, companyId, activityId);
            var activity = (activityResult as OkObjectResult).Value as Dtos.FsmActivity;
            if (activity == null)
                return NotFound();

            var allCompletedJobsForWorkOrderWithDetails = await OnsightFlowService.ImportJobsAsync(company, activity);

            return Ok(allCompletedJobsForWorkOrderWithDetails);
        }

        [HttpGet]
        [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]
        [Route("fsm/activity-workflows")]
        public async Task<IActionResult> GetWorkflowsForActivity(
            [FromQuery(Name = "h")] string cloudHost,
            [FromQuery(Name = "a")] string accountId,
            [FromQuery(Name = "c")] string companyId,
            [FromQuery(Name = "av")] string activityId,
            [FromQuery(Name = "email")] string fieldtechEmail)
        {
            var domainMapping = await DomainRepository.GetFromFsmAccountIdAsync(accountId);
            var company = domainMapping.FsmAccount.FindCompany(companyId);
            if (company == null)
               return NotFound();

            var selectedWorkFlowId = await FsmApiService.GetActivityUdfAsync(cloudHost, company, domainMapping, activityId);
            var getWorkflowsForActvitiy = await OnsightFlowService.AvailableWorkflowsAsync(company, selectedWorkFlowId, fieldtechEmail);

            return Ok(getWorkflowsForActvitiy);
        }

        /// <summary>
        /// Gets a Activity defined within the given CRM source object.
        /// 
        /// This endpoint is invoked by the web UI only (not mobile) and uses an internalKD
        /// Bearer token for authentication.
        /// </summary>
        /// <returns></returns>
        [HttpGet]
        [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]
        [Route("fsm/activity")]
        public async Task<IActionResult> GetActivity(
            [FromQuery(Name = "h")] string cloudHost,
            [FromQuery(Name = "a")] string accountId,
            [FromQuery(Name = "c")] string companyId,
            [FromQuery(Name = "av")] string activityId)
        {
            var domainMapping = await DomainRepository.GetFromFsmAccountIdAsync(accountId);

            var company = domainMapping.FsmAccount.FindCompany(companyId);
            if (company == null)
                return NotFound();

            var activity = await FsmApiService.GetActivityAsync(cloudHost, company, activityId);
            if (activity == null)
                return NotFound();

            return Ok(activity);
        }

        /// <summary>
        /// Fetches contact information about the Activity's remote expert. The expert is either:
        ///     a) designated using custom fields associated with the Activity's equipment, or
        ///     b) the Activity's Contact.
        /// </summary>
        /// <returns></returns>
        private async Task<Contact> GetRemoteExpertAsync(
            string cloudHost,
            CompanyInfo company,
            Dtos.FsmActivity activity,
            Dtos.FsmEquipment equipment,
            string fromEmail)
        {
            var expertName = string.Empty;
            var expertEmail = string.Empty;
            var expertTitle = string.Empty;

            // Use Equipment's designated expert, if available
            var equipmentContact = equipment?.RemoteExpert;
            if (equipmentContact != null)
            {
                expertName = equipmentContact.FirstName;
                expertEmail = equipmentContact.EmailAddress;
            }

            if (string.IsNullOrEmpty(expertEmail))
            {
                // Otherwise, fall back to using the Activity's Contact
                var activityContact = await FsmApiService.GetContactAsync(cloudHost, company, activity.Contact);
                expertEmail = activityContact.EmailAddress;

                // Bail out if we don't have an "expert" associated with the Activity
                if (string.IsNullOrEmpty(expertEmail))
                    return null;

                expertName = $"{activityContact.FirstName} {activityContact.LastName}";
                expertTitle = activityContact.PositionName;
            }

            return new Contact
            {
                Name = expertName,
                Title = expertTitle,
                Role = ContactRole.Expert,
                Connection = GetConnectionUrl(fromEmail, expertEmail, equipment?.Code, activity.Code)
            };
        }

        /// <summary>
        /// Helper which generates the /fsm/connection URL string.
        /// </summary>
        /// <param name="fromEmail"></param>
        /// <param name="toEmail"></param>
        /// <param name="equipmentCode"></param>
        /// <param name="activityCode"></param>
        /// <returns></returns>
        private string GetConnectionUrl(string fromEmail, string toEmail, string equipmentCode, string activityCode)
        {
            var meta = new StringBuilder();
            if (!string.IsNullOrEmpty(equipmentCode))
                meta.Append($"eqp:{equipmentCode};");
            if (!string.IsNullOrEmpty(activityCode))
                meta.Append($"act:{activityCode};");

            return Url.Action(
                nameof(GetConnection),
                "Connections",
                new
                {
                    from = fromEmail,
                    to = toEmail,
                    meta = meta.ToString()
                }
            );
        }
    }
}
